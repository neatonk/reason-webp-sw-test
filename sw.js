(function () {
'use strict';

function __(tag, block) {
  block.tag = tag;
  return block;
}


/* No side effect */

function is_nil_undef(x) {
  if (x === null) {
    return /* true */1;
  } else {
    return +(x === undefined);
  }
}


/* No side effect */

// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE
function accepts(mime, req) {
  var match = req.headers.get("accept");
  if (is_nil_undef(match)) {
    return /* false */0;
  } else {
    return +match.includes(mime);
  }
}

function cache_response(req, res) {
  var resClone = res.clone();
  return caches.open("v1").then(function (param) {
                return param.put(req, resClone);
              }).then(function () {
              return Promise.resolve(res);
            });
}

function fetch_no_resize(url) {
  var partial_arg = new Request(url);
  return fetch(url, {
                mode: "no-cors"
              }).then(function (param) {
              return cache_response(partial_arg, param);
            });
}

var jpeg_url_re = (/^(.+)\.jpe?g(?:\/([0-9]+))?$/);

function match_(req) {
  var url = req.url;
  if (accepts("webp", req)) {
    var match = url.match(jpeg_url_re);
    if (match !== null) {
      if (match.length !== 3) {
        return /* None */0;
      } else {
        var u = match[1];
        var w = match[2];
        var new_url = u + ".webp";
        if (w !== undefined) {
          return /* Resize */__(0, [
                    new_url,
                    parseInt(w, 10)
                  ]);
        } else {
          return /* NoResize */__(1, [new_url]);
        }
      }
    } else {
      return /* None */0;
    }
  } else {
    return /* None */0;
  }
}

function respond(req) {
  var match = match_(req);
  if (typeof match === "number") {
    return fetch(req);
  } else if (match.tag) {
    return fetch_no_resize(match[0]);
  } else {
    var url = match[0];
    return fetch_no_resize(url).then(function (prim) {
                  return prim.blob();
                }).then(function (blob) {
                return Promise.resolve(new Response(blob));
              });
  }
}

function app(req) {
  return caches.match(req).then(function (x) {
                if (is_nil_undef(x)) {
                  var req$1 = req;
                  return respond(req$1).then(function (param) {
                              return cache_response(req$1, param);
                            });
                } else {
                  return Promise.resolve(x);
                }
              }).catch(function (param) {
              var req$1 = req;
              var err = param;
              console.log(err);
              return fetch(req$1);
            });
}

self.onfetch = function (evt) {
  evt.respondWith(app(evt.request));
  return /* () */0;
};


/* jpeg_url_re Not a pure module */

}());
